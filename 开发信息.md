##
用户第三方登录的实现原理；
用户访问首页时，会进行cookie的token信息验证来确认当前登录状态，通过数据库中查找token对应信息来更新session信息，如果没有则需要有登录选项。
用户在前端输入登录信息和验证码后，首先在前台进行输入信息的效验，然后在数据库中查找用户对象
当用户在进行登录操作时，会将调用第三方的接口向第三方发出请求，以github为例，github会使用接口所设置的重定向uri并携带code验证信息，
此时这里的重定向uri即我们的系统会向github发出accestoken信息和code，github会验证accestoken信息并返回accesstoken到系统，
系统此时会发送user信息和accesstoken到github进行验证，如果accestoken正确，github会返回user信息，系统会进行数据库的信息存入和登录状态session的更新。
并跳转登录成功的页面。

单点登录实现方式：
认证中心的方式，在检测到session中没有token信息时，即确认未登录，会跳转到认证中心进行验证，如果之前未登录则重新登录，如果已经登陆则会进行token信息的添加。
拿到token后，还会再次向认证中心进行合法性验证，最后在进行token的cookie写入，当用户再次登录时则会携带这个token。本项目采用的这种方式。
常用的认证中心，APEREO-CAS和XXL-SSO
cookie作为父域名，设置Cookie的domain属性和path属性来决定cookie作用域，例如map.baidu.com和tieba.baidu.com。

在前后端分离的情况下可以完全不适用cookie而是用浏览器的localstorage存储sessionid达到同样的功能，此时只需将信息在前端写入不同域下面即可。

文章发布的流程；
首先在登录状态下才有发布按钮，前台需要接受的时文章的标题内容和标签。后端首先要进行内容的二次判错，获取发文者登录信息
然后进行文章对象的创建，并存入数据库，如果是作者需要更改文章，在这一步就是修改内容。

评论点赞的实现流程：
评论需要首先进行登陆状态判定，然后是文章的判空或者评论的判空，建立评论对象后更改评论数量。二级评论不支持子评论。
如果是一级评论先从数据库中查找问题，进行问题判空；插入评论，问题评论数增加一；
如果是二级评论，先从数据库中查找一级评论，先判空，设置一级评论id属性付给到二级评论的父类id属性，并自增评论的评论数；
评论完成后进行评论的数据库对象存入。
点赞功能：对于用户登录状态的检索，每个用户只能点赞一次该评论。评论后数量加一。

通知信息的实现：
对于其他用户的点赞评论操作会创建一个通知对象，通过点赞的状态来确认未读取的通知数量。
搜索和相关问题的简单实现：
这里主要是通过标签机制，在发布文章时我设定了一些有效标签，当用户选择自行输入无效标签会提示用户修改，通过标签可以筛选出相关类型的文章，且搜索也是通过在数据库中模糊查找对应标签的文章。

程序异常的处理机制；
首先自定义了系统中可能出现的异常枚举类型错误码和说明，然后在程序错误时会调用错误码对象得出错误内容，渲染出具体的错误显示页面给用户。

附加：
分页功能是通过page对象实现的，实际上有更简易的pagehelper框架减一实现。
##
在左半区的问题信息栏下加入回复的展示栏与回复的输入框
1、回复输入框：需要展示提问者的头像和用户名并隐式标出问题id；
加入文本框；框中的内容提交通过下方的评论按钮和js脚本实现
问题解决：自定义js函数comment（），通过jquery.val获取输入框中的内容和问题id；
首先需要进行内容判空；若空就不刷新返回错误信息；
以$.ajax()方式提交json请求，其中的content-type为application/json；
data中通过JSON.stringify()方法将问题id，评论内容和类型封装成JSON提交；
success：提交后进行服务器回应判断，正确刷新页面，错误进行登录判断，是则登录，如果不是则输出错误信息；
2、回复展示
第一栏展示回复总数后端question的commentCount属性
需要展示用户头像用户名日期，还有点赞和二级评论按钮；
th:each属性将后端传过来的comments遍历展示；
点赞和评论需要在焦点时变色，评论在按下时变色；通过css样式cusor和:hover解决
3、二级评论
给评论和二级评论一个动态的id使用th:id属性；二级评论加上子评论类标识；
二级评论按钮按下绑定自定义js函数collapseComments实现；
以.getAttribute()方法获取评论id和二级评论展开状态，通过jquery获取评论；
通过removeAttribute和.classList.remove/add标记和控制二级评论展开状态；
通过append追加的方式在评论后添加二级评论html代码；
二级评论提交方法在二级评论位置后面加上按钮，提交流程同一级评论；


##
一级评论：“/comment”，使用@ResponseBody标识mapping方法；接受前端传过来的CommentCreateDto对象；
二级评论：以“/comment/{id}”作为映射，@PathVariable实现,标识二级评论回传,依旧使用@ResonseBody标注代表只进行json数据交换；

comment:
Controller层：首先获取当前用户状态，进行判空和评论内容判空；然后新建comment对象，复制commentCreateDto中的三个属性后，插入评论user属性和时间，尝试进行插入service操作；
Service层：进行问题和类型判空，判断评论的类型是一级评论还是二级评论；
如果是一级评论先从数据库中查找问题，进行问题判空；插入评论，问题评论数增加一；
如果是二级评论，先从数据库中查找一级评论，先判空，设置一级评论id属性付给到二级评论的父类id属性，并自增评论的评论数；
service执行成功后从Controller返回前端一个请求成功ResultDTO的json对象；

QuestionController和commentController调用CommentService中的
评论展示：从controller中接受到需要展示的评论类型和父类id，通过id和类型查询到评论list集合并排序；
判空，先获取评论中去重的评论人，从数据库中查找评论人user和user的id组成map返回，
将评论和（评论的observer对应usermap的id）进行绑定成commentDtos集合，返回给controller；
cotroller在将其返回；一级评论存储在attribute域中，二级评论在前端



标签引入：在问题详情页的左边展示标签，右边展示相关问题，相关问题下方可插入广告位；
通过标签模糊查询在后端查到相关问题传到前端；

问题页面右半区,先添加广告位，然后是相关问题
相关问题使用th:each属性，遍历后端传过来的relatedQuestions;@{}用于url的拼接；
问题页面左半区：在标签上方加入div储存tag栏；通过遍历当前问题的tag并使用.split(',')以逗号分割；

通过正则实现模糊查询，添加到自定义的questionExtmapper.xml和对应类中
在questionController中添加查找查找相关问题的方法，将返回结果送到前端；
service实现这个方法:先判空，将标签中的‘,’替换为‘|’作为正则表达式；通过表达式找到对应问题数组，
将数组全部替换成questionDTOs然后返回给Controller；




发布栏标签的完善：
前端发布标签位置添加一个输入框的js，当点击到时可以弹出一个下拉导航框，框中显示传过来的标签库，并分栏展示，展示的标签需要点一下添加；
并作出标签的判断；
新建一个TagDTO有归类名和标签组的属性；使用一个TagCache用于给标签组赋值；
发布controller中，将Tags送到前端，并做一遍输入标签的过滤；

segemeant.fault

搜索功能的实现
iconfont
提问功能详情：
注册：
